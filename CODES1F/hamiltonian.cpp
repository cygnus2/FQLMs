/* construct the Hamiltonian matrix from the basis vectors */
#include<stdio.h>
#include<stdlib.h>
#include<iostream>
#include<fstream>
#include<math.h>
#include<vector>
#include<algorithm>
#include "define.h"
#include "mkl.h"
#include "mkl_solvers_ee.h"
#include "mkl_types.h"

void constH(std::vector<double> &evals, std::vector<std::vector<double>> &evecs){
   extern int scan(std::vector<bool>&);
   extern void printstate(std::vector<bool>&);
   extern void filter_flippable(void);
   extern void eigcheck(std::vector<double>&, std::vector<std::vector<double>>&); 
   extern void diag_matrix(std::vector<MKL_INT>&,std::vector<MKL_INT>&,std::vector<double>&, 
    std::vector<double>&, std::vector<std::vector<double>>&);
   extern void printbasis();
   int i,j,k,p,q;
   int p1,p2,p3,p4;
   std::vector<bool> newstate(2*VOL);
   std::vector<int> rowscan(VOL+1);  
   // rowscan stores the elements of the cartoon states generated by the action of the Hamiltonian
   // the maximal number of NEW states that can be generated by action of the Hamiltonian on the
   // basis state = VOL. In addition, the lambda counts the number of flippable terms in the state.
   std::vector<MKL_INT> rows,cols;
   std::vector<double> val;
   int stateq,curr_index;
   bool pxy,pyz,pzw,pwx;
   int n_Flip;

   /* compute the Hamiltonian */
   // example: access the basis
   // newstate = basis[4];
   // for(i=0;i<NTOT;i++) std::cout << i <<"  "<< (newstate==basis[i]) << std::endl;
  
   /* filter out the flippable from the non-flippable basis states */ 
   filter_flippable();
   //printbasis();
   curr_index=1;
   rows.push_back(curr_index);
   printf("Going to construct the Hamiltonian. \n");
   for(i=0;i<NH;i++){
     //printf("i= %d \n",i); 
     n_Flip = 0;
     newstate = basis_flip[i];
     /* act on the basis state with the Hamiltonian */
     /* a single plaquette is arranged as 
                pzw
             o-------o
             |       |
        pwx  |   p   |  pyz
             |       |
             o-------o
                pxy
     */
     // Assign some large number here, which will always be at the end after the sort
     for(j=0;j<=VOL;j++) rowscan[j]=NH;
     stateq = 0;
     for(p=0;p<VOL;p++){
       // Find if a single plaquette is flippable 
       p1=2*p; p2=2*next[DIM+1][p]+1; p3=2*next[DIM+2][p]; p4=2*p+1;
       pxy=newstate[p1]; pyz=newstate[p2]; pzw=newstate[p3]; pwx=newstate[p4];
       if((pxy==pyz)&&(pzw==pwx)&&(pwx!=pxy)){
         // If flippable, act with the Hamiltonian 
         //std::cout<<"Acting with H on plaq "<<j<<" of state "<<i<<" "<<std::endl;
         //printstate(newstate);
         newstate[p1]=!newstate[p1]; newstate[p2]=!newstate[p2]; 
         newstate[p3]=!newstate[p3]; newstate[p4]=!newstate[p4];
         //printstate(newstate);
         q=scan(newstate);
         // store the position matrix element (i,stateq) 
         rowscan[stateq]=q; stateq++;
         //flip back the plq
         newstate[p1]=!newstate[p1]; newstate[p2]=!newstate[p2]; 
         newstate[p3]=!newstate[p3]; newstate[p4]=!newstate[p4];
         //if(newstate!=basis_flip[i]) std::cout<<"state mismatch"<<std::endl;
         // count the number the flippable plaquettes in this basis state
         n_Flip++;
       }
     }
     //store the diagonal location
     rowscan[stateq]=i; stateq++;
     // check
     if(stateq > (VOL+1)){ printf("Error in bound.\n"); }
     // sort the matrix columns
     std::sort (rowscan.begin(), rowscan.end());
     //for(k=0;k<=VOL;k++) if(rowscan[k]<NH) printf("%d ",rowscan[k]);
     //printf("\n");
     // construct the matrix in CSC format
     curr_index = curr_index + stateq;
     rows.push_back(curr_index);
     for(k=0;k<stateq;k++){
       cols.push_back(rowscan[k]+1); 
       if(rowscan[k]==i) val.push_back(lam*n_Flip);
       else val.push_back(-1.0);
     }
     // construct the diagonal observable Oflip;
     //std::cout<<"#-of-flippable plaquettes in basis state-"<<i<<"= "<<n_Flip<<std::endl;
     Oflip.push_back(n_Flip); 
   }
 //printf("size of rows = %d \n",(int)rows.size());
 //for(k=0;k<rows.size();k++) printf("row[%d] = %d \n",k,rows[k]);
 //printf("size of cols = %d \n",(int)cols.size());
 //for(k=0;k<cols.size();k++) printf("col[%d] = %d \n",k,cols[k]);
 //printf("elements = %d \n",(int)val.size());
 //for(k=0;k<val.size();k++) printf("val[%d] = %f \n",k,val[k]);
 // diagonalize
 diag_matrix(rows,cols,val,evals,evecs);
 //eigcheck(evals,evecs);
 //std::ofstream Outfile;
 //int nrows, ncols;
 //nrows = rows.size(); ncols = cols.size();
 //Outfile.open("sparse_mat.bin",std::ios::out);
 //Outfile.write((char*)&nrows, sizeof(int));
 //Outfile.write((char*)&ncols, sizeof(int));
 //Outfile.write((char*)&rows[0], rows.size()*sizeof(MKL_INT));
 //Outfile.write((char*)&cols[0], cols.size()*sizeof(MKL_INT));
 //Outfile.close();
 }

 int scan(std::vector<bool> &newstate){
   for(int m=0;m<NH;m++){
     if(newstate==basis_flip[m]) return m;
   }
   return -100;
 }

 void filter_flippable(){
   unsigned int i,j,nonflip_count; 
   bool non_flip;
   std::vector<bool> temp(2*VOL);
   int p,p1,p2,p3,p4;
   bool pxy,pyz,pzw,pwx;

   printf("In filter_flippable(). Size of full basis = %d\n",(int)basis.size());
   nonflip_count=0;
   for(i=0;i<NTOT;i++){
     non_flip=true; 
     temp=basis[i];
     for(j=0;j<VOL;j++){
       p=chk2lin[j]; 
       p1=2*p; p2=2*next[DIM+1][p]+1; p3=2*next[DIM+2][p]; p4=2*p+1;
       pxy=temp[p1]; pyz=temp[p2]; pzw=temp[p3]; pwx=temp[p4];
       if((pxy==pyz)&&(pzw==pwx)&&(pwx!=pxy)) non_flip=false;
     }
     if(non_flip){
       basis_nonflip.push_back(temp);
       nonflip_count++;
     }
     else{
       basis_flip.push_back(temp);
     }
   }
   NH = NTOT - nonflip_count;
   printf("No of non-flip basis states = %d\n",nonflip_count);
   printf("size of flippable basis = %d\n",(int)basis_flip.size());
   printf("size of non-flippable basis = %d\n",(int)basis_nonflip.size());
   basis.clear();
 }

 void printstate(std::vector<bool> &newstate){
  for(unsigned int k=0;k<2*VOL;k++) std::cout<<newstate[k]<<" ";
  std::cout<<" "<<std::endl;
 }

 /* Matrix val of size N in CSR format. Size N and 3 arrays are used to store matrix in CSR format */
 void diag_matrix(std::vector<MKL_INT> &rows, std::vector<MKL_INT> &cols, std::vector<double> &val, 
    std::vector<double> &evals, std::vector<std::vector<double>> &evecs){
     unsigned int k;
     std::vector<double> temp_vec;
     // simple checks
     // printf("size of rows = %d \n",(int)rows.size());
     //for(k=0;k<rows.size();k++) printf("row[%d] = %d \n",k,rows[k]);
     // printf("size of cols = %d \n",(int)cols.size());
     // for(k=0;k<cols.size();k++) printf("col[%d] = %d \n",k,cols[k]);
 
     char UPLO = 'F'; /* Type of matrix: (F means full matrix, L/U - lower/upper triangular part of matrix) */
     const MKL_INT N = rows.size()-1;

     /* Declaration of FEAST variables */
     MKL_INT  fpm[128];      /* Array to pass parameters to Intel MKL Extended Eigensolvers */
     MKL_INT* r=&rows[0];
     MKL_INT* c=&cols[0];
     double*  v=&val[0];
     double   Emin, Emax;    /* Lower/upper bound of search interval [Emin,Emax] */
     double   epsout;        /* Relative error on the trace */
     MKL_INT  loop;          /* Number of refinement loop */
     MKL_INT  L = N;         /* should not be more than the linear dim of the matrix */
     MKL_INT  M0;            /* Initial guess for subspace dimension to be used */
     MKL_INT  M;             /* Total number of eigenvalues found in the interval */

     //double   E[N];         /* Eigenvalues */
     //double   X[N*N];       /* Eigenvectors */
     //double   res[N];       /* Residual */
     double   *E;         /* Eigenvalues */
     double   *X;       /* Eigenvectors */
     double   *res;       /* Residual */
     E = (double*)(calloc(N,sizeof(double)));
     X = (double*)(calloc(N*N,sizeof(double)));
     res = (double*)(calloc(N,sizeof(double)));

     /* Declaration of local variables */
     MKL_INT  info;          /* Errors */
     //double   Y[N][N];     /* Y=(X')*X-I */

     //char     DGEMMC = 'T';  /* Character for GEMM routine, transposed case */
     //char     DGEMMN = 'N';  /* Character for GEMM routine, non-transposed case */
     double   one = 1.0;     /* alpha parameter for GEMM */
     double   zero = 0.0;    /* beta  parameter for GEMM */
     //MKL_INT  ldx = N;      /* Leading dimension for source arrays in GEMM */
     //MKL_INT  ldy = N;      /* Leading dimension for destination array in GEMM */

     MKL_INT  i, j;
     double   trace, smax, eigabs;

     printf("\n FEAST DFEAST_SCSREV \n");
     /* Initialize matrix X */
     for (i=0; i<N*N; i++) X[i] = zero;
     printf("Sparse matrix size %i\n", (int)N);
     /* Search interval [Emin,Emax] */
     Emin = -16.0;
     Emax =  16.0;
     printf("Search interval [ %.15e, %.15e  ]  \n", Emin, Emax);

     M0   = L;
     M    = L;
     loop = 0;
     info = 0;
     epsout = 0.0;
 
     /* Step 1. Call  FEASTINIT to define the default values for the input FEAST parameters */
     feastinit(
        fpm /* OUT: Array is used to pass parameters to Intel MKL Extended Eigensolvers */
        );

     fpm[0] =  1; /* Extended Eigensolver routines print runtime status to the screen. */

     /* Step 2. Solve the standard Ax = ex eigenvalue problem. */
     printf("dfeast_scsrev routine:\n");
     dfeast_scsrev(
        &UPLO,   /* IN: UPLO = 'F', stores the full matrix */
        &N,      /* IN: Size of the problem */
        v,       /* IN: CSR matrix A, values of non-zero elements */
        r,       /* IN: CSR matrix A, index of the first non-zero element in row */
        c,       /* IN: CSR matrix A, columns indices for each non-zero element */
        fpm,     /* IN/OUT: Array is used to pass parameters to Intel MKL Extended Eigensolvers */
        &epsout, /* OUT: Relative error of on the trace */
        &loop,   /* OUT: Contains the number of refinement loop executed */
        &Emin,   /* IN: Lower bound of search interval */
        &Emax,   /* IN: Upper bound of search interval */
        &M0,     /* IN: The initial guess for subspace dimension to be used. */
        E,       /* OUT: The first M entries of Eigenvalues */
        X,       /* IN/OUT: The first M entries of Eigenvectors */
        &M,      /* OUT: The total number of eigenvalues found in the interval */
        res,     /* OUT: The first M components contain the relative residual vector */
        &info    /* OUT: Error code */
        );
     printf("FEAST OUTPUT INFO %d \n",info);
     if ( info != 0 ){
        printf("Routine dfeast_scsrev returns code of ERROR: %i", (int)info);
     }
     /* print eigenvalues and eigenvectors */
     //printf("Number of eigenvalues found %d \n", M);
     //for(i=0;i<M;i++) printf("Eig val %d = % e \n",i,E[i]);
     //printf("Eigenvectors = \n");
     //for(i=0;i<M;i++){
     //  printf("Eigenvector %d  = (",i);
     //  for(j=0;j<M;j++) printf("% .4f",X[i*M+j]);
     //  printf(")\n");
     //}

    // save the eigenvalues + eigenvectors to return to the main code
    for(i=0;i<M;i++){
      evals.push_back(E[i]);
      temp_vec.clear();
      for(j=0;j<M;j++) temp_vec.push_back(X[i*M+j]); 
      evecs.push_back(temp_vec);
    }
    free(E); free(X); free(res);
}

 void eigcheck(std::vector<double> &evals, std::vector<std::vector<double>> &evecs){
  extern double **allocatedouble2d(int, int);
  extern void deallocatedouble2d(double**, int, int);
  double  *X,*Y; 
  double smax;
  double one=1.0, zero=0.0;
  int i,j;
  for(i=0;i<NH;i++) std::cout<<"Eigenvalue "<<i<<" = "<<evals[i]<<std::endl;
  for(i=0;i<NH;i++){ 
     for(j=0;j<NH;j++) printf("% .5f ",evecs[i][j]);
     printf("\n");
  }

  char DGEMMC = 'T'; 
  char DGEMMN = 'N';
  Y = (double*)(calloc(NH*NH,sizeof(double)));
  X = (double*)(calloc(NH*NH,sizeof(double)));
  for(i=0;i<NH;i++)
  for(j=0;j<NH;j++)
    X[i*NH+j] = evecs[i][j];

  dgemm(
        &DGEMMC, /* IN: 'T', transposed case*/
        &DGEMMN, /* IN: 'N', non-transposed case*/
        &NH,      /* IN: Number of rows in matrix Y */
        &NH,      /* IN: Number of columns in matrix X */
        &NH,      /* IN: Number of columns in matrix Y */
        &one,    /* IN: alpha = 1.0 */
        X,       /* IN: Source #1 for GEMM, will be transposed */
        &NH,    /* IN: Leading dimension of Source 1 */
        X,       /* IN: Source #2 for GEMM */
        &NH,    /* IN: Leading dimension of Source 2 */
        &zero,   /* IN: beta = 0.0 */
        Y,       /* OUT: Destination */
        &NH     /* IN: Leading dimension of Destination */
        );
  for (i=0; i<NH; i++) Y[i*NH+i] -= 1.0;
  smax = 0.0;
  for (i=0; i<NH; i++)
  for (j=0; j<NH; j++)
     smax = (smax > fabs(Y[i*NH+j])? smax:fabs(Y[i*NH+j]));
  printf( "Max(X' * X - I) = %.15e \n", smax);
  free(Y);

 }
 
 
